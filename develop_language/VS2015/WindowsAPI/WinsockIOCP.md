# Winsock IO模型之IOCP模型

 Windows平台上伸缩性最好的一种I/O模型莫过IOCP了，不过设计和实现起来比较复杂一些。针对成千上万个套接字的并发处理，IOCP采用了线程池+队列+重叠结构的内核机制完成任务。需要说明的是IOCP其实不仅可以接收套接字对象句柄，还可以接收文件对象句柄等。

 为避免线程上下文切换，它采用了线程池。除此之外，在基于事件模型或重叠模型中不得不遇到`WSAWaitForMultipleEvent`的`WSA_MAXIMUM_WAIT_EVENTS`的限制，由此必须由自己来设计线程池来避开这种限制。而`IOCP`则由系统来实现线程池，对用户来说透明，由此减少了设计线程池带来的复杂性并提高了安全性。看看`GetQueuedCompletionStatus`这个函数，它包含了封包队列排队机制以及基于事件的重叠结构`OVERLAPPED`的通知，用户无需再去设计`队列`和`OVERLAPPED结构`中显式地创建事件。

 `IOCP`一般被用于`Windows平台`上大规模服务器程序的设计。所以设计起来有很多地方需要注意。因为`IOCP`设计中需要用到很多`异步操作`，所以对到来的数据包的排序是需要额外处理的，每个封包添简单和常用的方法是为加一个序列号。接收方每接收一个封包就需要判断其是否为当前需要读取的下一个序列号封包，如果不是就要将之插入封包队列，如果是则返回给用户。

 当关闭`IOCP`时，我们要避免重叠操作正在进行的时候却要释放它的`OVERLAPPED结构`，阻止其发生的最好方法是在每个套接字句柄上调用`closesocket`，如此所有的未决重叠`IO操作`都会完成。

 一旦所有的套接字句柄关闭，就该终止`IOCP`上处理`IO的工作线程`了。这可以通过`PostQueuedCompletionStatus`来操作。在接收连接方面，投递多少连接是个需要认真考虑的问题，因为每创建一个套接字都会占用系统不小的开销，在`Win2000`及以后版本中我们可以通过在创建监听套接字时采用`WSAEventSelect`，注册`FD_ACCEPT`通知消息的方式，在投递的`AcceptEx`用完时但仍有客户连接时，事件对象将会受信，通知我们继续投递。另外，我们可以对每个客户套接字采用定时轮询的方法查询其连接时间长短，以此我们可以判断哪些客户连接有恶意的迹象（只连接服务器不发送任何数据）。

    采用书上的一个例子，其中增加Keeplive机制，并修订了其中的几个错误。